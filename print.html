<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cu-summer-stem-embedded-systems</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="The Cooper Union - Summer STEM Embedded Systems: C-ing Beyond Arduino">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-3865ffda.css">
        <link rel="stylesheet" href="css/general-4c35105a.css">
        <link rel="stylesheet" href="css/chrome-c0e702bf.css">
        <link rel="stylesheet" href="css/print-ad67d350.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome-799aeb25.css">
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight-56612340.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-702485fc.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-d5c7b32d.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cu-summer-stem-embedded-systems</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cu-summer-stem-embedded-systems"><a class="header" href="#cu-summer-stem-embedded-systems">cu-summer-stem-embedded-systems</a></h1>
<blockquote>
<p>The Cooper Union - Summer STEM Embedded Systems: C-ing Beyond Arduino</p>
</blockquote>
<p>Starting with programming an Arduino Uno Rev3 with the Arduino framework and progressing to bare-metal C on the underlying AVR microcontroller, students will dive headfirst into the embedded world where all the safety is off, and all our favorite abstractions are gone.
Students will start with an Arduino and get comfortable interfacing with hardware using digital IO, PWM, ADCs, interrupts, and communications protocols like UART &amp; I2C.
Once familiar, the facade will get peeled away, and students will get a rundown of a Unix shell, computer architecture, compilers, build systems, and debuggers.
Using this new-found knowledge, students will go through the paces of writing a device driver using one of the available memory-mapped peripherals on an AVR microcontroller to gain familiarity with bare-metal C.
Throughout the course, students will get constant exposure to practical embedded applications and by the end, will have to come up with and implement an embedded application from scratch.</p>
<p><strong>Student outcomes:</strong></p>
<ul>
<li>Gain familiarity with embedded tools and hardware devices.</li>
<li>The ability to apply embedded programming techniques.</li>
<li>Successfully traverse datasheets and sample code.</li>
<li>Debugging techniques (software and hardware) along with collaboration.</li>
</ul>
<h2 id="copyright--licensing"><a class="header" href="#copyright--licensing">Copyright &amp; Licensing</a></h2>
<p>Copyright (C) 2025 Jacob Koziej <a href="mailto:jacobkoziej@gmail.com"><code>&lt;jacobkoziej@gmail.com&gt;</code></a></p>
<p>Distributed under the <a href="LICENSE"><code>CC-BY-NC-SA-4.0</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syllabus"><a class="header" href="#syllabus">Syllabus</a></h1>
<p>The following is a tentative syllabus for the Summer of 2025.
Please check this site frequently for the most up-to-date information.</p>
<h2 id="course-overview"><a class="header" href="#course-overview">Course Overview</a></h2>
<p><strong>Instructor:</strong> Jacob Koziej (EE ’25)</p>
<p><strong>Teaching Assistants:</strong> Marco Chen (EE ’28), Matthew Jeong (EE ’28), Charles Wan (STEM ’25)</p>
<p><strong>Location</strong>: 41 Cooper Square, Room 603 (ICE Lab)</p>
<p><strong>Time:</strong> Monday–Thursday, 09:00–15:00</p>
<p><strong>Office Hours:</strong> On request</p>
<p><strong>Contact:</strong> TEAMs message or email (<a href="mailto:jacob.koziej@cooper.edu"><code>&lt;jacob.koziej@cooper.edu&gt;</code></a>)</p>
<h2 id="prerequisite-skills"><a class="header" href="#prerequisite-skills">Prerequisite Skills</a></h2>
<p>Proficiency in any programming language; this could be something as simple as a block-based language<sup class="footnote-reference" id="fr-snap-1"><a href="#footnote-snap">1</a></sup>.</p>
<h2 id="course-goals"><a class="header" href="#course-goals">Course Goals</a></h2>
<p>The ultimate goal of this course is to familiarize you enough with embedded development that you can continue exploring beyond Arduino or move away from embedded as a more informed engineer.
By the end of the summer, you should be able to:</p>
<ul>
<li>Identify &amp; establish engineering problem requirements.</li>
<li>Decompose problems into digestible sub-problems.</li>
<li>Find and parse datasheets and reference manuals for relevant information.</li>
<li>Make sense of unfamiliar code.</li>
<li>Organize a programming project.</li>
<li>Write clean, effective, and defensive C code.</li>
<li>Debug with software and hardware.</li>
<li>Work with others on an engineering problem.</li>
<li>Understand the social implications of your work.</li>
<li>Be comfortable with being uncomfortable.</li>
</ul>
<p>This course aims to address the following <a href="https://abet.org">ABET</a> student outcomes:</p>
<ol>
<li>An ability to identify, formulate, and solve complex engineering problems by applying principles of engineering, science, and mathematics.</li>
<li>An ability to apply engineering design to produce solutions that meet specified needs with consideration of public health, safety, and welfare, as well as global, cultural, social, environmental, and economic factors.</li>
<li>An ability to communicate effectively with a range of audiences.</li>
<li>An ability to recognize ethical and professional responsibilities in engineering situations and make informed judgments, which must consider the impact of engineering solutions in global, economic, environmental, and societal contexts.</li>
<li>An ability to function effectively on a team whose members together provide leadership, create a collaborative environment, establish goals, plan tasks, and meet objectives.</li>
<li>An ability to develop and conduct appropriate experimentation, analyze and interpret data, and use engineering judgment to draw conclusions.</li>
<li>An ability to acquire and apply new knowledge as needed, using appropriate learning strategies.</li>
</ol>
<h2 id="policy"><a class="header" href="#policy">Policy</a></h2>
<p>Overall, I am a <em>very</em> understanding and flexible person, but please don’t force my hand.</p>
<h3 id="ask-questions"><a class="header" href="#ask-questions">Ask Questions</a></h3>
<blockquote>
<p>The man who asks a question is a fool for a minute, the man who does not ask is a fool for life. (Confucius)</p>
</blockquote>
<p>At times, my mind moves too fast for my own good, and I may skip steps.
<strong>If you are confused at any moment for any reason, please stop me.</strong>
I can guarantee you are not the only person in the room feeling that way.
I do understand it may be difficult to come forward with questions in a class environment, so I’ll also be providing a real-time anonymous question board you can take advantage of.
Finally, if you’re so confused that you cannot compose a meaningful question, <strong>please reach out</strong>, and we’ll work together to identify the root of the problem.</p>
<h3 id="attendance"><a class="header" href="#attendance">Attendance</a></h3>
<p>Attendance is mandatory.
We’ll be starting at 09:00 sharp as starting later is unfair to the students who made an effort to get to class on time.
If you are running late, please inform me at least 15 minutes before the start of class so that I can take note.
In the event of an absence, please inform both me and Dr. Thevenot.</p>
<h3 id="course-work"><a class="header" href="#course-work">Course Work</a></h3>
<p>I expect all relevant work from the day to be submitted (even if incomplete).
Work will not be explicitly graded, however, I plan to return a commented diff by the start of the next class.
At the start of each class, we might spend some time reviewing any common errors made in assignments.</p>
<h3 id="academic-integrity"><a class="header" href="#academic-integrity">Academic Integrity</a></h3>
<p><strong>I do not tolerate cheating of any kind.</strong>
If I have reasonable suspicion that you have cheated, I will report you to Cooper Union’s administration for a formal review.</p>
<p>It is painfully obvious when I read code that includes code not written by you.
That is not to say you cannot use online resources or LLMs, but I do expect proper attribution.
<strong>If you’re using just a snippet of code, type it out, and if possible, refactor it to fit the flow of your code.</strong>
I intend for such a practice to get you in the habit of understanding the code you read so that you can grow as a programmer.
That said, using larger snippets becomes problematic due to licensing, which could land you in legal trouble!</p>
<p><strong>tldr:</strong> write everything yourself!</p>
<h2 id="course-structure"><a class="header" href="#course-structure">Course Structure</a></h2>
<p>This course is segmented into three, two-week units.
With the exception of the last unit, we’ll try to stick to the following daily schedule:</p>
<ul>
<li>09:00–10:00 - Lecture for background/motivation</li>
<li>10:00–12:00 - Interactive lesson</li>
<li>12:00–13:00 - Lunch</li>
<li>13:00–15:00 - In-class assignment(s)</li>
</ul>
<p>At the end of each week, we will spend less time on learning and instead focus more on a single-day project.
The goal of this project is to encompass everything we covered during the week but also to prepare you for your open-ended final project.</p>
<h3 id="background"><a class="header" href="#background">Background</a></h3>
<p>In this unit, we’ll do a run-through of how to interact with Arduinos.
The first week will primarily focus on the basics of Arduino and useful parts of the C programming language when working in an embedded setting.
In the second week, we’ll set up a debugger to effectively navigate timers, interrupts, and communication peripherals.</p>
<h3 id="c-ing-beyond-arduino"><a class="header" href="#c-ing-beyond-arduino">C-ing Beyond Arduino</a></h3>
<p>In this unit, we’ll leave the Arduino framework behind and will start programming the ATmega328P on the Arduino Uno Rev3 directly.
In the first week, we’ll familiarize ourselves with interacting with the ATmega328P without a GUI or libraries; doing so entails becoming comfortable with the terminal, along with reading datasheets and sample code.
In the second week, we’ll explore the peripheral systems of the ATmega328P and learn how to work around its limitations.</p>
<h3 id="final-project"><a class="header" href="#final-project">Final Project</a></h3>
<p>In this final unit, we’ll work on an open-ended two-week final project in small groups.
This project will revolve around using the ATmega328P in a “real world” application where you’ll have the chance to work with sensors and hardware not covered in class; however, do keep in mind that some parts have long lead times.
We’ll also have drop-in lessons as necessary to ensure we finish in time for the final showcase.</p>
<h2 id="student-resources"><a class="header" href="#student-resources">Student Resources</a></h2>
<p><strong>Accommodations:</strong> <a href="https://cooper.edu/students/student-affairs/disability">https://cooper.edu/students/student-affairs/disability</a></p>
<p><strong>Mental Health Services:</strong> <a href="https://cooper.edu/students/student-affairs/health/counseling">https://cooper.edu/students/student-affairs/health/counseling</a></p>
<p><strong>Title IX:</strong> <a href="https://cooper.edu/students/student-affairs/sexual-misconduct">https://cooper.edu/students/student-affairs/sexual-misconduct</a></p>
<hr>
<ol class="footnote-definition"><li id="footnote-snap">
<p>I actually got started programming Arduinos with only a background in <a href="https://snap.berkeley.edu">Snap!</a> <a href="#fr-snap-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="background-1"><a class="header" href="#background-1">Background</a></h1>
<p>Tentative schedule:</p>
<ul>
<li><strong>2025-07-08:</strong> <a href="background/hello-world.html">Hello, World!</a></li>
<li><strong>2025-07-09:</strong> <a href="background/analog-&amp;-serial.html">Analog &amp; Serial</a></li>
<li><strong>2025-07-10:</strong> <a href="background/debugging.html">Debugging</a></li>
<li><strong>2025-07-14:</strong> <a href="background/bit-manipulation-&amp;-lookup-tables.html">Bit Manipulation &amp; Lookup Tables</a></li>
<li><strong>2025-07-15:</strong> <a href="background/circular-buffers.html">Circular Buffers &amp; Seven Segment Displays</a></li>
<li><strong>2025-07-16:</strong> <a href="background/timers-&amp;-state-machines.html">Timers &amp; State Machines</a></li>
<li><strong>2025-07-17:</strong> <a href="background/interrupts.html">Interrupts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p><em>Getting the ball rolling with Arduino.</em></p>
<h2 id="outline"><a class="header" href="#outline">Outline</a></h2>
<ul>
<li>The basics of Information Theory, in particular, defining entropy</li>
<li>Working with different numeral systems:
<ul>
<li>Decimal, Binary, Octal, &amp; Hexadecimal</li>
<li>Two’s complement</li>
<li>Quick conversion between Binary, Octal, &amp; Hexadecimal</li>
</ul>
</li>
<li>Circuit fundamentals:
<ul>
<li>Ohm’s Law</li>
<li>Series vs Parallel</li>
<li>Power</li>
<li>Analog vs Digital</li>
</ul>
</li>
<li>Arduino basics:
<ul>
<li>Using the <a href="https://docs.arduino.cc/language-reference/">language reference</a></li>
<li><a href="https://docs.arduino.cc/language-reference/en/structure/sketch/setup/"><code>setup()</code></a> &amp; <a href="https://docs.arduino.cc/language-reference/en/structure/sketch/loop/"><code>loop()</code></a></li>
<li>Interfacing with digital IO</li>
<li>Delaying actions</li>
<li>Defining variables and constants</li>
<li>Arithmetic operations and assignment</li>
<li><a href="https://docs.arduino.cc/language-reference/en/structure/control-structure/if/"><code>if</code></a>-<a href="https://docs.arduino.cc/language-reference/en/structure/control-structure/else/"><code>else</code></a> statements</li>
</ul>
</li>
<li>Debouncing buttons</li>
<li>Crude debugging with an LED</li>
</ul>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p>In an attempt to absorb as much information as possible during the lesson, you suffer an exceptionally unexpected event and magically become stranded on an island with nothing but a laptop and your trusty Arduino.
To make matters worse, it’s night, and a new moon is out.</p>
<ol>
<li>
<p>Right as you’re about to start cursing your luck, you remember that the Arduino Uno Rev3 has a built-in LED, and there are some fishers about a mile out from the island.
Using your newfound knowledge, write a program to blink SOS so that you can make it back in time for tomorrow’s lesson!</p>
</li>
<li>
<p>Fortunately for you, the fishers noticed your SOS, shot a flare, and are now heading your way.
Unfortunately, you notice unsettling noises coming from the bushes not too far from you.
Thinking quickly, you decide to change the LED blinking pattern to be irritating and scare away anything from coming out to the beach.
Write a program that blinks the built-in LED in a range between 50 and 500 milliseconds.
Change the delay by 50 milliseconds every cycle, alternating between increasing and decreasing the delay depending on whether the delay time is saturated.</p>
</li>
<li>
<p>Having been rescued by the fishers, as a token of appreciation (and as a practical joke), you decide to make them a counter that keeps track of the number of fish that got away in a day.
They only have four LEDs, some resistors, and two push buttons on board.
Being resourceful, you build them a 4-bit, unsigned counter.
Write a program that displays in binary the number of fish that got away.
One button should increment the counter while the other should reset it back to zero.
If the counter overflows, turn on the built-in LED and turn off the remaining LEDs.</p>
</li>
</ol>
</li>
<li>
<p>Being soon-to-be broke college students, you’ll need to be resourceful with what you have on hand.
To prepare you for this reality, let’s create a dimmable Arduino night light using the built-in LED and a push button.
We can achieve this by varying the percentage of time we power the LED.
However, we need to perform this switching at a high enough frequency (&gt;1 kHz) so that we cannot perceive the flickering.
Utilize a push button to create 10 different LED brightness levels along with an off state.
The push button should cycle between increasing the brightness and turning off the LED.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analog--serial"><a class="header" href="#analog--serial">Analog &amp; Serial</a></h1>
<p><em>More interesting interactions with the world.</em></p>
<h2 id="outline-1"><a class="header" href="#outline-1">Outline</a></h2>
<ul>
<li>Quantization</li>
<li>Pulse-Width Modulation (PWM)</li>
<li>Potentiometers</li>
<li>Analog to Digital Conversion (ADC)</li>
<li><a href="https://docs.arduino.cc/language-reference/en/functions/math/map/"><code>map()</code></a> function</li>
<li>Hysteresis</li>
<li><a href="https://docs.arduino.cc/language-reference/en/functions/communication/serial/"><code>Serial</code></a> communication:
<ul>
<li>RX vs TX</li>
<li>Baud rate</li>
<li>Parity</li>
<li>Serialization</li>
<li>Serial console</li>
</ul>
</li>
<li>ASCII encoding</li>
<li>RGB(A) color model</li>
<li>RGB LEDs</li>
<li><a href="https://docs.arduino.cc/language-reference/en/functions/communication/serial/"><code>Serial</code></a> debugging</li>
</ul>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>
<p>In anticipation of building your own audio amplifier, you decide to create a volume indicator.
Using four LEDs, create a 4-LED volume indicator where a potentiometer serves as the volume knob.
Ensure that hysteresis is added to each of the volume regions to prevent flickering of volume levels.</p>
</li>
<li>
<p>Since I’m a huge Pink Floyd fan, let’s pick <a href="https://open.spotify.com/track/6FBPOJLxUZEair6x4kLDhf">Any Colour You Like</a>.
Utilize three potentiometers to change the color of an RGB LED to any color you like.
<strong>Optionally</strong>, add a button to dim the LED brightness by 50%.</p>
</li>
<li>
<p>Since moving our hands from the keyboard is such a hassle, let’s instead utilize the serial console to control the color of the LED.
Your code should expect a valid hex RGB value followed by a newline.
If this value is malformed, return an error to the user with a meaningful error code; otherwise, return a success code.
<strong>Optionally</strong>, add support for an optional alpha channel.
If the user supplies no alpha channel, assume alpha is 100%.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p><em>Squash one bug and two more may appear.</em></p>
<h2 id="outline-2"><a class="header" href="#outline-2">Outline</a></h2>
<ul>
<li>Recursion</li>
<li>debugWire</li>
<li>Breakpoints</li>
<li>Watchpoints</li>
<li>Mutating memory</li>
<li>Evaluating expressions</li>
</ul>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>
<p>Implement Fizz Buzz up to a number specified over the serial console.</p>
</li>
<li>
<p>Create a recursive factorial function.
This function should be able to at least successfully calculate 10 factorial.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-manipulation--lookup-tables"><a class="header" href="#bit-manipulation--lookup-tables">Bit Manipulation &amp; Lookup Tables</a></h1>
<p><em>Squeezing and pre-computing data.</em></p>
<h2 id="outline-3"><a class="header" href="#outline-3">Outline</a></h2>
<ul>
<li>Standard integer types</li>
<li>Endianness</li>
<li>Bitwise operations:
<ul>
<li>AND</li>
<li>OR</li>
<li>XOR</li>
<li>NOT</li>
<li>Left shift</li>
<li>Right shift</li>
</ul>
</li>
<li>Bit masks</li>
<li>Bit packing</li>
<li><code>enum</code>erations</li>
<li>Lookup tables</li>
<li><a href="https://docs.arduino.cc/language-reference/en/variables/utilities/sizeof/"><code>sizeof</code></a> operator</li>
<li><a href="https://docs.arduino.cc/language-reference/en/variables/variable-scope-qualifiers/static/"><code>static</code></a> storage class qualifier</li>
<li>Seven-segment displays</li>
</ul>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li>
<p>You’re working on an embedded system where a service technician needs to know status information at a glance.
To fulfill this requirement, you and your team decide that it’d be easiest to display a status code using a hex code.
Luckily, there’s only 16 different status states your system can assume, so a single seven segment display appears to be the perfect choice, however there’s only one problem: the hardware team still doesn’t know which pins on the microcontroller are going to be easiest to route to your seven segment display on the multi-layer PCB.
Being the brilliant engineer you are, you decide to create a lookup table that allows you to easily map segments to pins.
With this lookup table in mind, write code that displays any value between 0 and 15 on a seven-segment display.
Make sure to create a bit-packed lookup table for each of the hex digits.
To ensure your code works, continuously cycle through 0 and 15.</p>
</li>
<li>
<p>You’re working on a communication protocol, and following some clever math over <a href="https://en.wikipedia.org/wiki/GF(2)">GF(2)</a>, you end up with a <code>uint64_t</code> where each bit represents an irrecoverable bit error.
Since you’re working on a real-time system, you need to quickly determine if the number of bit errors is still recoverable.
Write code that counts the number of bits set in a <code>uint64_t</code>.
Make your code interactive by allowing a user to specify any integer over serial and reporting the number of bits set back to the user.</p>
</li>
<li>
<p>Since you’re working in an embedded environment, memory is a scarce resource, making logging a headache.
During the engineering design process, you and your team decide that you need to keep track of the occurrence of an event over the last eight time steps.
Write code that cyclically fills a <code>uint8_t</code> where we represent the presence of an event by a set bit.
When you press one push button, read the value of another to determine the occurrence of the event.
<strong>Optionally</strong>, add another button that will print the last eight events over serial when pressed.
During setup, zero the buffer to assume no events have happened.</p>
</li>
<li>
<p><strong>(Challenge)</strong> When dealing with a vast amount of binary data, corruption is inevitable.
Due to this possibility, we need a method to determine if our data has changed so that we can act accordingly.
One method is to utilize a 32-bit <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Check</a> (CRC-32).
Implement a function that computes a CRC-32 given an array of <code>uint8_t</code>’s and the number of bytes using the standard IEEE polynomial of <code>0x04C11DB7</code> and initial condition of <code>0xFFFFFFFF</code>.
<strong>Remember</strong>, endianness matters here!
You might need to use the reversed version of the polynomial.
Create an array with the message “cooper union” and check if your function reports a correct CRC-32.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circular-buffers"><a class="header" href="#circular-buffers">Circular Buffers</a></h1>
<p><em>Don’t look too far ahead; you might see what you’ve left behind.</em></p>
<h2 id="outline-4"><a class="header" href="#outline-4">Outline</a></h2>
<ul>
<li>Modular arithmetic</li>
<li>Circular buffers</li>
<li>Multiplexing</li>
</ul>
<h2 id="project"><a class="header" href="#project">Project</a></h2>
<p><em>Scrolling quad seven-segment display.</em></p>
<ol>
<li>Create two lookup tables: one that maps seven-segment display segments to pins and another that maps digits to pins.</li>
<li>Write a function that, given a <code>uint8_t</code> bitmask, displays it on a seven-segment digit.</li>
<li>Write code that multiplexes between the different digits of the display.
At this point, it should look as if all the digits are on at the same time.</li>
<li>Write a function that, given ASCII digits, letters, or the space character, returns an index into a lookup table of associated seven-segment bitmasks.</li>
<li>Implement a circular text buffer that can repeatedly scroll on your display.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers--state-machines"><a class="header" href="#timers--state-machines">Timers &amp; State Machines</a></h1>
<p><em>We can’t describe everything in terms of finite states, but that sure hasn’t stopped us from trying.</em></p>
<h2 id="outline-5"><a class="header" href="#outline-5">Outline</a></h2>
<ul>
<li><a href="https://docs.arduino.cc/language-reference/en/functions/time/millis/"><code>millis()</code></a> &amp; <a href="https://docs.arduino.cc/language-reference/en/functions/time/micros/"><code>micros()</code></a></li>
<li>Super loops</li>
<li><a href="https://docs.arduino.cc/language-reference/en/functions/random-numbers/random/"><code>random()</code></a> &amp; <a href="https://docs.arduino.cc/language-reference/en/functions/random-numbers/randomSeed/"><code>randomSeed()</code></a></li>
<li><code>struct</code>ures</li>
<li><code>typedef</code>initions</li>
<li><a href="https://docs.arduino.cc/language-reference/en/structure/control-structure/switchCase/"><code>switch</code></a>-<a href="https://docs.arduino.cc/language-reference/en/structure/control-structure/switchCase/"><code>case</code></a>s</li>
<li>State machines</li>
</ul>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li>
<p>Blink two LEDs every 389 and 991 milliseconds.</p>
</li>
<li>
<p>I miss the days of bringing quarters to school for a snack at the vending machine, so let’s make one to bring this childhood memory of mine back to life!
Create a simple state machine to turn your Arduino into a vending machine!
Your state machine should have the following states:</p>
<ul>
<li>Collecting quarters</li>
<li>Item dispensing</li>
<li>Returning change (if any)</li>
</ul>
<p>Since this is a “proof of concept” device, let’s make the following simplifications:</p>
<ul>
<li>Print status information to the serial console to let the user know what’s going on.</li>
<li>Pressing a button adds a quarter.</li>
<li>Pressing a button will toggle between items.</li>
<li>Pressing a button returns users their change.</li>
</ul>
<p>And to complicate things a bit, let’s consider the following:</p>
<ul>
<li>Have at least three different priced items with a finite stock.</li>
<li>Add a 30s timeout from the last inserted quarter. On timeout, return all change.</li>
<li>Randomly reject quarters at a 1% rate and let users know about this failure.</li>
<li>Blink the built-in LED every second so users know the machine is still on.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h1>
<p><em>Like a crying child, some things just need your attention right away.</em></p>
<h2 id="outline-6"><a class="header" href="#outline-6">Outline</a></h2>
<ul>
<li>The Fourier Transform</li>
<li>Hardware low-pass filter for debouncing</li>
<li>Ultrasonic sensors</li>
<li>Interrupts</li>
<li><a href="https://docs.arduino.cc/language-reference/en/functions/external-interrupts/attachInterrupt/"><code>attachInterrupt()</code></a>, <a href="https://docs.arduino.cc/language-reference/en/functions/external-interrupts/detachInterrupt/"><code>detachInterrupt()</code></a>, &amp; <a href="https://docs.arduino.cc/language-reference/en/functions/external-interrupts/digitalPinToInterrupt/"><code>digitalPinToInterrupt()</code></a></li>
<li><a href="https://docs.arduino.cc/language-reference/en/functions/interrupts/interrupts/"><code>interrupts()</code></a> &amp; <a href="https://docs.arduino.cc/language-reference/en/functions/interrupts/noInterrupts/"><code>noInterrupts()</code></a></li>
<li>Function prototypes</li>
<li>Header files</li>
<li>Multi-file sketches</li>
<li>Quadrature encoders</li>
</ul>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li>Utilize interrupts to keep track of encoder steps.
Create a separate source file that encapsulates your encoder functionality and expose the current encoder steps with a function that has the following signature: <code>uint32_t encoder_steps(void)</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-ing-beyond-arduino-1"><a class="header" href="#c-ing-beyond-arduino-1">C-ing Beyond Arduino</a></h1>
<p>Tentative schedule:</p>
<ul>
<li><strong>2025-07-22:</strong> <a href="c-ing-beyond-arduino/hello-again.html">Hello, Again!?</a></li>
<li><strong>2025-07-23:</strong> <a href="c-ing-beyond-arduino/shift-registers.html">Shift Registers</a></li>
<li><strong>2025-07-28:</strong> <a href="c-ing-beyond-arduino/pointers.html">Pointers</a></li>
<li><strong>2025-07-30:</strong> <a href="c-ing-beyond-arduino/timers-&amp;-pwm.html">Timers &amp; PWM</a></li>
<li><strong>2025-07-31:</strong> <a href="c-ing-beyond-arduino/twi.html">2-wire Serial Interface</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-again"><a class="header" href="#hello-again">Hello, Again!?</a></h1>
<p><em>Let’s run it back.</em></p>
<h2 id="outline-7"><a class="header" href="#outline-7">Outline</a></h2>
<ul>
<li>Using the shell:
<ul>
<li>File paths</li>
<li>Core utilities</li>
<li><code>man</code> pages</li>
</ul>
</li>
<li>Compilation process</li>
<li>Compiler flags</li>
<li><code>Makefile</code>s</li>
<li><code>load</code>ing programs with <code>avr-gdb</code></li>
<li>Reading:
<ul>
<li>Schematics</li>
<li>Datasheets</li>
</ul>
</li>
<li>Digital IO with port registers</li>
</ul>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<ol>
<li>Blink the built-in LED of the Arduino Uno Rev3.</li>
<li>Toggle the built-in LED of the Arduino Uno Rev3 using a push button.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shift-registers"><a class="header" href="#shift-registers">Shift Registers</a></h1>
<p><em>Why worry about IO when you can throw more at the problem?</em></p>
<h2 id="outline-8"><a class="header" href="#outline-8">Outline</a></h2>
<ul>
<li>Shift registers</li>
</ul>
<h2 id="exercises-7"><a class="header" href="#exercises-7">Exercises</a></h2>
<ol>
<li>Take your quad seven-segment project and port it over to AVR C.
Instead of setting the state of each segment individually, map them to PORT D so that they can all update in one write.</li>
<li>Now, take your code from the previous exercise, but instead use a shift register to control the individual segments.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointers"><a class="header" href="#pointers">Pointers</a></h1>
<p><em>If you thought shooting yourself in the foot hurt, just wait till you blow off your leg!</em></p>
<h2 id="outline-9"><a class="header" href="#outline-9">Outline</a></h2>
<ul>
<li>Harvard vs Von Neumann architecture</li>
<li>Pointers:
<ul>
<li><code>NULL</code></li>
<li>Pointer arithmetic</li>
<li><code>uintptr_t</code></li>
</ul>
</li>
<li>Multi-level pointers</li>
<li>Function pointers</li>
<li><code>void</code> pointers</li>
<li><code>_Static_assert()</code></li>
</ul>
<h2 id="exercises-8"><a class="header" href="#exercises-8">Exercises</a></h2>
<ol>
<li>
<p>Let’s make our own digital IO functions like the Arduino framework!</p>
<ol>
<li>
<p>Create <code>digital.c</code> and <code>digital.h</code> files; these will store your digital IO functionality.</p>
</li>
<li>
<p>Create a function with the following signature: <code>volatile uint8_t *digital_pin_to_port(uint8_t pin)</code>.
If you reference the register summary of the ATmega328P datasheet, you’ll see that the port registers reside next to one another; use this information to your advantage to simplify your logic.
If the user specifies an invalid pin number, return <code>NULL</code>.</p>
</li>
<li>
<p><code>typedef</code> an <code>enum</code> called <code>digital_register_type_t</code> to let us specify if we’re interested in <code>PORTx</code>, <code>DDRx</code>, or <code>PINx</code> of a port register.</p>
</li>
<li>
<p>Create a function with the following signature: <code>volatile uint8_t *digital_port_offset(volatile uint8_t * const port, digital_register_type_t type)</code>.
If you define <code>digital_register_type_t</code> in a clever manner, you can simply add the value of <code>type</code> to <code>port</code> to get the correct offset.
To make sure this works as intended, add static assertions to your header to make sure that your <code>enum</code> values are indeed valid offsets.</p>
</li>
<li>
<p>Create a function with the following signature: <code>int digital_pin_to_bit(uint8_t pin)</code>.
This function should return the bit offset of a pin inside a port register.
If the user specifies an invalid pin number, return <code>-1</code>.</p>
</li>
<li>
<p><code>typedef</code> an <code>enum</code> called <code>digital_mode_t</code> to let us specify if we’re interested in <code>INPUT</code>, <code>OUTPUT</code>, or <code>INPUT_PULLUP</code>.</p>
</li>
<li>
<p>Create functions with the following signatures:</p>
<ul>
<li><code>bool digital_pin_mode(uint8_t pin, digital_mode_t mode)</code></li>
<li><code>bool digital_write(uint8_t pin, bool high)</code></li>
<li><code>bool digital_read(uint8_t pin, bool * const pin_state)</code></li>
</ul>
<p>These functions should make calls to all three of the previous helper functions to simplify the internals and return <code>true</code> or <code>false</code> to indicate the success of execution.</p>
</li>
</ol>
</li>
<li>
<p>Rewrite your vending machine state machine to utilize a lookup table of function pointers to remove the existing <code>switch</code>-<code>case</code>.
Remove all uses of global variables; instead, pass a pointer to a shared <code>static struct</code> in your state machine function.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers--pwm"><a class="header" href="#timers--pwm">Timers &amp; PWM</a></h1>
<p><em>Good design demands good compromise.</em></p>
<h2 id="outline-10"><a class="header" href="#outline-10">Outline</a></h2>
<ul>
<li>SREG</li>
<li>Timers:
<ul>
<li>Groups</li>
<li>Prescalers</li>
<li>Interrupt sources</li>
<li>Clear conditions</li>
</ul>
</li>
<li>PWM:
<ul>
<li>Output compare unit</li>
<li>Fast PWM</li>
<li>Phase correct PWM</li>
</ul>
</li>
<li>AVR-LIBC ISRs</li>
</ul>
<h2 id="exercises-9"><a class="header" href="#exercises-9">Exercises</a></h2>
<ol>
<li>Create your function to keep track of microseconds.
This function should utilize an 8-bit timer and an overflow interrupt to return an accurate 64-bit result.</li>
<li>Set the highest clock prescaler for the 16-bit timer and observe how different PWM modes behave when switching output compare values between <code>1 &lt;&lt; 15</code> and <code>1 &lt;&lt; 14</code>.
Make sure to utilize the output compare interrupt to make switching between these two values seamless.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-wire-serial-interface"><a class="header" href="#2-wire-serial-interface">2-wire Serial Interface</a></h1>
<p><em>“Did you know that the 2-wire serial interface is compatible with Phillips’ I2C protocol!?” - Matthew Jeong</em></p>
<h2 id="outline-11"><a class="header" href="#outline-11">Outline</a></h2>
<ul>
<li>I2C:
<ul>
<li>SDA &amp; SCL</li>
<li>Master vs slave devices</li>
<li>START and STOP conditions</li>
<li>Addressing</li>
<li>Reading vs writing</li>
<li>ACK vs NACK</li>
<li>Multi-master configuration</li>
</ul>
</li>
<li>TWI:
<ul>
<li>Modes of operation</li>
<li>TWI registers</li>
<li>Clock generation</li>
<li>TWI interrupt</li>
</ul>
</li>
<li>MPU-6050:
<ul>
<li>Applications</li>
<li>Requesting data</li>
<li>External interrupt</li>
</ul>
</li>
<li>Drivers:
<ul>
<li>Definition</li>
<li>Non-blocking, interrupt-driven design</li>
</ul>
</li>
</ul>
<h2 id="project-1"><a class="header" href="#project-1">Project</a></h2>
<p><em>MPU-6050 driver.</em></p>
<ol>
<li>
<p>Create a <code>twi</code> translation unit for your TWI driver.
This translation unit must at the very least contain the following functions:</p>
<ul>
<li><code>twi_status_t twi_init(const uint32_t scl_frequency)</code></li>
<li><code>twi_status_t twi_enqueue(twi_message_t *messages, size_t message_count)</code></li>
<li><code>twi_status_t twi_status(void)</code></li>
<li><code>twi_status_t twi_cancel(void)</code></li>
<li><code>twi_status_t twi_deinit(void)</code></li>
</ul>
<p>To simplify this assignment, we’ll only consider master mode operation.
To make our lives significantly easier, I suggest we take the following steps:</p>
<ol>
<li>Set the associated digital IO ports to inputs with their internal pull-up resistors enabled.
This will allow us to avoid having to attach external pull-up resistors. However, please note that with these enabled, we can’t set the SCL’s frequency above 100 kHz.</li>
<li><code>typedef</code> an <code>enum</code> called <code>twi_status_t</code>.
This <code>enum</code> should contain a list of TWI status codes your functions can return to indicate success, failure, or nominal operation.</li>
<li><code>typedef</code> a <code>struct</code> called <code>twi_message_t</code>.
This <code>struct</code> should contain a pointer to a <code>uint8_t</code> buffer our driver can read from/write to, along with a size for this buffer in bytes.</li>
<li>Define a <code>static</code> function for calculating our clock pre-scaler and <code>TWBR</code> values given an SCL frequency.</li>
<li>Populate <code>ISR(TWI_vect)</code> with an empty <code>switch</code>-<code>case</code> using constants defined in <a href="https://avrdudes.github.io/avr-libc/avr-libc-user-manual/group__util__twi.html"><code>&lt;util/twi.h&gt;</code></a> related to master mode.
Instead of directly <code>switch</code>ing on <code>TWSR</code>, utilize the <code>TW_STATUS</code> macro as it will automatically mask non-zero pre-scaler bits.
Do note that a few of the status operations can be the same, so fall-through <code>case</code>s might be useful to reduce code duplication.</li>
<li>Create a <code>static struct</code> local to the <code>twi</code> translation unit that will contain all variables we might share between the ISR and regular functions.</li>
<li><code>twi_init()</code> should set the SCL frequency on a best-effort basis, along with initializing the TWI peripheral to be in an idle state.
This function is also a great point to set default values for any variables we will use in our ISR.</li>
<li><code>twi_enqueue()</code> should pass a pointer to a message or array of messages (if we intend to utilize the repeat START condition) along with a count of the number of messages we’ll be transmitting to internal variables used in our ISR before successfully returning to the caller.
There should also be some basic checks in place here to ensure that we don’t interrupt an existing operation.
In the case of an ongoing operation, we should fail gracefully and return control to the caller.</li>
<li>At this point, we can start filling out our <code>switch</code>-<code>case</code> in our ISR.
I recommend looking at <a href="https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ApplicationNotes/ApplicationNotes/00002480A.pdf">application note AVR315</a>, which guides you through an <a href="https://ww1.microchip.com/downloads/en/AppNotes/Atmel-2564-Using-the-TWI-Module-as-I2C-Master_ApplicationNote_AVR315.zip">example master TWI driver</a>.<sup class="footnote-reference" id="fr-warning-1"><a href="#footnote-warning">1</a></sup>
If you read the AVR315 application note or ATmega328P datasheet, you’ll notice that the TWI peripheral is a state machine we control with a handful of registers.
I suggest tracing out possible execution paths and finding terminal states on success or failure.
In either case, you should pass status information to the user, along with indicating that the operation has concluded.</li>
<li><code>twi_status()</code> gives our calling code a glimpse into what’s happening in the background so that it can act accordingly.
Once the enqueued TWI operation is complete, this function should return success to the caller, who can access any read data or enqueue a new operation.</li>
<li>In the case of the I2C bus failing, you may want to timeout an operation.
<code>twi_cancel()</code> serves the purpose of rescuing our code from this limbo as opposed to hanging like older versions of the <a href="https://docs.arduino.cc/language-reference/en/functions/communication/wire/">Arduino Wire library</a>.</li>
<li>Finally, add the ability to disable TWI entirely with <code>twi_deinit()</code>.
In the case of an ongoing operation or an uninitialized TWI peripheral, this function should fail gracefully.</li>
</ol>
</li>
<li>
<p>Create an <code>mpu-6050</code> translation unit for your MPU-6050 driver.
<strong>Functions and steps are TBD.</strong></p>
</li>
</ol>
<hr>
<ol class="footnote-definition"><li id="footnote-warning">
<p>Be highly skeptical of manufacturer code or other code you find on the internet!
At least for the Atmel code linked above, it includes a few mistakes and poor design decisions:</p>
<ul>
<li>Unbounded busy loops checking <code>TWINT</code>, which may never be unset if the I2C bus is disconnected.</li>
<li>Variables shared between regular functions and the ISR that are not <code>volatile</code>.</li>
<li><code>TWSR</code> pre-scaler bits are not masked when checking TWI status bits, so a non-zero pre-scaler renders the driver useless.</li>
<li><code>TWCR</code> is always overwritten, irrespective of user settings.
For example, a user may wish to keep <code>TWEA</code> disabled for whatever reason.</li>
<li>Time and space get wasted copying buffered data to an internal TWI data buffer.</li>
</ul>
<p>There might not be all the errors, but the point still stands: code from manufacturers or the general internet should be nothing more than a reference and/or starting point, as opposed to an infallible source of truth! <a href="#fr-warning-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="final-project-1"><a class="header" href="#final-project-1">Final Project</a></h1>
<p>Tentative schedule:</p>
<ul>
<li><strong>2025-08-06:</strong> <a href="final-project/git.html">Git</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<p><em>git gud kid</em></p>
<h2 id="outline-12"><a class="header" href="#outline-12">Outline</a></h2>
<ul>
<li>Git:<sup class="footnote-reference" id="fr-missing-semester-1"><a href="#footnote-missing-semester">1</a></sup>
<ul>
<li>Data model</li>
<li>References</li>
<li><a href="https://nvie.com/posts/a-successful-git-branching-model/">Gitflow</a></li>
<li>Basic commands</li>
<li><a href="https://git-scm.com/docs/git-config"><code>.gitconfig</code></a></li>
<li><a href="https://git-scm.com/docs/gitignore"><code>.gitignore</code></a></li>
</ul>
</li>
<li>GitHub:
<ul>
<li><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">Connecting with SSH</a></li>
<li><a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository">Creating a repository</a></li>
<li><a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request">Creating a pull request</a></li>
</ul>
</li>
<li>Problem decomposition</li>
<li>Project organization</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-missing-semester">
<p><a href="https://missing.csail.mit.edu/2020/version-control/">MIT’s Missing Semester lecture on Git</a> is a great place to start when learning this powerful tool! <a href="#fr-missing-semester-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<ul>
<li><a href="examples/ascii-remap.html">ASCII Remap</a></li>
<li><a href="examples/button-debounce.html">Button Debounce</a></li>
<li><a href="examples/circular-buffer.html">Circular Buffer</a></li>
<li><a href="examples/lookup-tables.html">Lookup Tables</a></li>
<li><a href="examples/makefile.html">Makefile</a></li>
<li><a href="examples/state-machine.html">State Machine</a></li>
<li><a href="examples/timer-delay.html">Timer Delay</a></li>
<li><a href="examples/ultrasonic-interrupt.html">Ultrasonic Interrupt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ascii-remap"><a class="header" href="#ascii-remap">ASCII Remap</a></h1>
<pre><code class="language-cpp">static const uint32_t BAUD = 115200;

static const uint8_t DIGITS = 10;
static const uint8_t INVALID_INDEX = 255;

static uint8_t ascii_to_index(const unsigned char c)
{
  if ((c &gt;= '0') &amp;&amp; (c &lt;= '9'))
    return c - '0';

  if ((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z'))
    return c - 'A' + DIGITS;

  if ((c &gt;= 'a') &amp;&amp; (c &lt;= 'z'))
    return c - 'a' + DIGITS;

  return INVALID_INDEX;
}

void setup(void)
{
  Serial.begin(BAUD);

  Serial.println(ascii_to_index('4'));
  Serial.println(ascii_to_index('J'));
  Serial.println(ascii_to_index('K'));
  Serial.println(ascii_to_index('!'));
}

void loop(void)
{
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button-debounce"><a class="header" href="#button-debounce">Button Debounce</a></h1>
<pre><code class="language-cpp">static const uint8_t BUTTON = 2;

static const uint8_t DEBOUNCE_MS = 4;

static bool button_state;

void setup(void)
{
  pinMode(BUTTON, INPUT);

  pinMode(LED_BUILTIN, OUTPUT);

  digitalWrite(LED_BUILTIN, button_state);
}

void loop(void)
{
  // get our initial sample of the button
  bool button_sample = digitalRead(BUTTON);

  // wait for the button to settle
  delay(DEBOUNCE_MS);

  // if the current sample is the same as the
  // previous we assume the new button state
  if (digitalRead(BUTTON) == button_sample)
    button_state = button_sample;

  digitalWrite(LED_BUILTIN, button_state);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circular-buffer"><a class="header" href="#circular-buffer">Circular Buffer</a></h1>
<pre><code class="language-cpp">static const char MESSAGE[] = "cooper union ";

static const uint8_t WINDOW_SIZE = 4;

// exclude the NULL character when calculating the size
static const uint8_t MESSAGES_SIZE = sizeof(MESSAGE) - 1;

static const uint32_t BAUD     = 115200;
static const uint16_t DELAY_MS = 500;

void setup(void)
{
  Serial.begin(BAUD);
}

void loop(void)
{
  static uint8_t index;

  for (size_t i = 0; i &lt; WINDOW_SIZE; i++)
    Serial.print(MESSAGE[(index + i) % MESSAGES_SIZE]);

  Serial.print('\n');

  index = (index + 1) % MESSAGES_SIZE;

  delay(DELAY_MS);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lookup-tables"><a class="header" href="#lookup-tables">Lookup Tables</a></h1>
<pre><code class="language-cpp">enum {
  RED,
  GREEN,
  BLUE,
  COLORS_TOTAL,
};

static const uint16_t ADC_MAX = (1 &lt;&lt; 10) - 1;
static const uint8_t  PWM_MAX = (1 &lt;&lt; 8)  - 1;

static const uint8_t COLOR_TO_PIN[COLORS_TOTAL] = {
  [RED]   = 9,
  [GREEN] = 10,
  [BLUE]  = 11,
};

static const uint8_t POTENTIOMETER_TO_PIN[COLORS_TOTAL] = {
  [RED]   = A0,
  [GREEN] = A1,
  [BLUE]  = A2,
};

void setup(void)
{
  for (size_t i = 0; i &lt; COLORS_TOTAL; i++) {
    pinMode(POTENTIOMETER_TO_PIN[i], INPUT);

    pinMode(COLOR_TO_PIN[i], OUTPUT);
    digitalWrite(COLOR_TO_PIN[i], LOW);
  };
}

void loop(void)
{
  for (size_t i = 0; i &lt; COLORS_TOTAL; i++) {
    const uint16_t sample = analogRead(POTENTIOMETER_TO_PIN[i]);
    analogWrite(COLOR_TO_PIN[i], map(sample, 0, ADC_MAX, 0, PWM_MAX));
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="makefile"><a class="header" href="#makefile">Makefile</a></h1>
<pre><code class="language-Makefile">CC      = avr-gcc
CFLAGS += \
	-DF_CPU=16000000ULL \
	-O0 \
	-Wall \
	-Wextra \
	-Wpedantic \
	-g \
	-mmcu=atmega328p \
	-std=gnu17 \

.PHONY: all
all: main.elf

.PHONY: clean
clean:
	@rm -rvf *.d *.elf *.o

main.elf: main.o foo.o bar.o
	$(CC) $(CFLAGS) -o $@ $^

%.o: %.c
	$(CC) $(CFLAGS) -MM -MF $*.d $&lt;
	$(CC) $(CFLAGS) -c $&lt;

-include $(wildcard *.d)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-machine"><a class="header" href="#state-machine">State Machine</a></h1>
<pre><code class="language-cpp">enum {
  BUTTON_MODE,
  BUTTON_ACTION,
  BUTTONS_TOTAL,
};

static const uint8_t BUTTON_TO_PIN[BUTTONS_TOTAL] = {
  [BUTTON_MODE]   = 2,
  [BUTTON_ACTION] = 4,
};

enum {
  STATE_ADD,
  STATE_SUB,
  STATE_CLEAR,
  STATES_TOTAL,
};

static const uint32_t BAUD = 115200;

static int32_t count;

static bool button_rising(const int button)
{
  static uint8_t previous_state[BUTTONS_TOTAL];

  const uint8_t current_state = digitalRead(BUTTON_TO_PIN[button]);

  const bool rising = !previous_state[button] &amp;&amp; current_state;

  previous_state[button] = current_state;

  return rising;
}

static int state_add(void)
{
  if (button_rising(BUTTON_MODE))
    return STATE_SUB;

  if (button_rising(BUTTON_ACTION)) {
    ++count;

    Serial.print("Count: ");
    Serial.println(count);
  }

  return STATE_ADD;
}

static int state_sub(void)
{
  if (button_rising(BUTTON_MODE))
    return STATE_CLEAR;

  if (button_rising(BUTTON_ACTION)) {
    --count;

    Serial.print("Count: ");
    Serial.println(count);
  }

  return STATE_SUB;
}

static int state_clear(void)
{
  if (button_rising(BUTTON_MODE))
    return STATE_ADD;

  if (button_rising(BUTTON_ACTION)) {
    count = 0;

    Serial.println("Count cleared");
  }

  return STATE_CLEAR;
}

void setup(void)
{
  for (size_t i = 0; i &lt; BUTTONS_TOTAL; i++)
    pinMode(BUTTON_TO_PIN[i], INPUT);

  Serial.begin(BAUD);
}

void loop(void)
{
  static uint8_t state;

  uint8_t new_state;

  switch (state) {
    case STATE_ADD: {
      new_state = state_add();
      break;
    };

    case STATE_SUB: {
      new_state = state_sub();
      break;
    };

    case STATE_CLEAR: {
      new_state = state_clear();
      break;
    };

    default: {
      new_state = STATE_ADD;
      break;
    };
  }

  if (state != new_state) {
    Serial.print("LOG: transitioning from state");
    Serial.print(state);
    Serial.print(" to ");
    Serial.print(new_state);
    Serial.println();
  }

  state = new_state;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timer-delay"><a class="header" href="#timer-delay">Timer Delay</a></h1>
<pre><code class="language-cpp">static const uint32_t DELAY_US = 500000;

static uint32_t previous_time_us;

void setup(void)
{
  digitalWrite(LED_BUILTIN, LOW);
  pinMode(LED_BUILTIN, OUTPUT);

  previous_time_us = micros();
}

void loop(void)
{
  uint32_t current_time_us;

  if ((current_time_us = micros()) - previous_time_us &gt;= DELAY_US) {
    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));

    previous_time_us = current_time_us;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ultrasonic-interrupt"><a class="header" href="#ultrasonic-interrupt">Ultrasonic Interrupt</a></h1>
<pre><code class="language-cpp">static const uint8_t ECHO_PIN    = 2;
static const uint8_t TRIGGER_PIN = 4;

/*
 * In Standard Temperature and Pressure (STP), sound travels at 343 m/s.
 * Here we define this constant but in terms of microseconds to make it
 * easy for us to convert to meters given our measurement in
 * microseconds.
 */
static const float STP_SOUND_METERS_PER_US = 343e-6f;

static const uint32_t BAUD            = 115200;
static const uint8_t  PULSE_LENGTH_US = 10;
static const uint8_t  SAMPLE_DELAY_MS = 10;

static volatile bool     pulse_ready;
static volatile uint16_t pulse_time_us;

static void echo_isr(void)
{
  /*
   * NOTE: On ATmega328P, only one interrupt can execute at a time. This
   * becomes problematic when using millis() or micros() inside of an
   * interrupt context as the underlying timers which drive these
   * functions are only 16-bit! This means the upper 16 bits of the
   * returned value is stored independent of the timer value and
   * incremented with an overflow interrupt. Since timers don't stop in
   * interrupt contexts, it's possible for the timer to overflow between
   * the start and end times, causing a possible erroneous reading of
   * about (1 &lt;&lt; 32) - (1 &lt;&lt; 16). To avoid this, we only store the lower
   * 16 bits of the return value of millis() or micros(), more
   * specifically, the actual timer value, allowing us to avoid this
   * issue all together!
   */
  static uint16_t pulse_start_us;

  // erroneous interrupt
  if (pulse_ready)
    return;

  if (digitalRead(ECHO_PIN)) {
    pulse_start_us = micros();

    return;
  }

  const uint16_t pulse_end_us = micros();

  pulse_time_us = pulse_end_us - pulse_start_us;
  pulse_ready   = true;
}

void setup(void)
{
  pinMode(ECHO_PIN, INPUT);

  digitalWrite(TRIGGER_PIN, LOW);
  pinMode(TRIGGER_PIN, OUTPUT);

  Serial.begin(BAUD);

  attachInterrupt(digitalPinToInterrupt(ECHO_PIN), echo_isr, CHANGE);
}

void loop(void)
{
  pulse_ready = false;

  digitalWrite(TRIGGER_PIN, HIGH);
  delayMicroseconds(PULSE_LENGTH_US);
  digitalWrite(TRIGGER_PIN, LOW);

  // NOTE: your code can be doing other things while we wait for the
  // pulse to come in, like timeout---we just have nothing to do
  while (!pulse_ready)
    continue;

  // since the pulse travels to the object and back, we need to divide
  // the total time in half since we measure double the distance
  const float distance_m = STP_SOUND_METERS_PER_US * (pulse_time_us / 2);

  Serial.print(distance_m);
  Serial.println("m");

  // if we don't wait here, the HC-SR04 becomes unhappy and doesn't
  // ever send the next pulse we request :(
  delay(SAMPLE_DELAY_MS);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bug-hall-of-fame"><a class="header" href="#bug-hall-of-fame">Bug Hall of Fame</a></h1>
<ul>
<li><a href="bug-hall-of-fame/static-initialization.html">Static Initialization</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-initialization"><a class="header" href="#static-initialization">Static Initialization</a></h1>
<p>While working through our quadrature encoder activity, I gave a hint to the class that by applying a bitwise XOR to channels A and B on a <a href="https://docs.arduino.cc/language-reference/en/functions/external-interrupts/attachInterrupt/#parameters"><code>CHANGE</code> interrupt</a>, you could quickly determine the direction of rotation.
The trouble started soon thereafter with three different situations:</p>
<ul>
<li>the encoder step count could increment or decrement</li>
<li>the encoder step count only increments or decrements, but not both</li>
<li>or the encoder step count would oscillate around a value.</li>
</ul>
<p>What I’d like to do is introduce two similar, but <em>very</em> different acting bits of code:</p>
<h4 id="staticcc"><a class="header" href="#staticcc"><a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/static.cc"><code>static.cc</code></a></a></h4>
<pre><code class="language-cpp">static const uint8_t PIN_ENCODER_CHANNEL_A = 2;
static const uint8_t PIN_ENCODER_CHANNEL_B = 3;

static volatile int32_t steps;

void channel_a_isr(void)
{
  static bool A = digitalRead(PIN_ENCODER_CHANNEL_A);
  static bool B = digitalRead(PIN_ENCODER_CHANNEL_B);

  steps += A ^ B ? 1 : -1;
}
</code></pre>
<h4 id="intcc"><a class="header" href="#intcc"><a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/int.cc"><code>int.cc</code></a></a></h4>
<pre><code class="language-cpp">static const uint8_t PIN_ENCODER_CHANNEL_A = 2;
static const uint8_t PIN_ENCODER_CHANNEL_B = 3;

static volatile int32_t steps;

void channel_a_isr(void)
{
  int A = digitalRead(PIN_ENCODER_CHANNEL_A);
  int B = digitalRead(PIN_ENCODER_CHANNEL_B);

  steps += A ^ B ? 1 : -1;
}
</code></pre>
<hr />
<p>In this case, <a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/int.cc"><code>int.cc</code></a> works while <a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/static.cc"><code>static.cc</code></a> does not!</p>
<h2 id="a-deep-dive"><a class="header" href="#a-deep-dive">A Deep Dive</a></h2>
<p>The astute reader may have already spotted the mistake; I for one did not on my first time around.<sup class="footnote-reference" id="fr-tunnel-vission-1"><a href="#footnote-tunnel-vission">1</a></sup>
Part of why this code had me pulling my hair out was the expression <code>steps += A ^ B ? 1 : -1</code>, which did different things between people in the class.
Initially, I suspected some strange integer promotion being done by the compiler, but this necessitated a deeper analysis!</p>
<h3 id="assembly-output"><a class="header" href="#assembly-output">Assembly Output</a></h3>
<p>What I ended up doing was extracting <em>some</em> of the <a href="https://github.com/arduino/ArduinoCore-avr/blob/1.8.6/platform.txt">compilation flags from the Arduino AVR core</a> and <a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/Makefile">manually compiling</a> a code sample with <code>avr-g++</code>.
Conveniently, GCC offers the <code>-S</code> and <code>-fverbose-asm</code> flags, which output assembly and add verbose assembly comments, respectively.
Throwing this together, we get the following (unoptimized) output for a subset of <code>channel_a_isr</code>:</p>
<h4 id="statics"><a class="header" href="#statics"><a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/static.s"><code>static.s</code></a></a></h4>
<pre><code> ;  static.cc:13:   static bool A = digitalRead(PIN_ENCODER_CHANNEL_A);
	ldi r24,lo8(_ZGVZ13channel_a_isrvE1A)	 ;  _ZGVZ13channel_a_isrvE1A.0_1,
	ldi r25,hi8(_ZGVZ13channel_a_isrvE1A)	 ;  _ZGVZ13channel_a_isrvE1A.0_1,
	movw r30,r24	 ; , _ZGVZ13channel_a_isrvE1A.0_1
	ld r24,Z		 ;  _2, MEM[(char *)_ZGVZ13channel_a_isrvE1A.0_1]
	cp r24, __zero_reg__	 ;  _2
	brne .L2		 ; ,
 ;  static.cc:13:   static bool A = digitalRead(PIN_ENCODER_CHANNEL_A);
	ldi r24,lo8(2)	 ; ,
	call digitalRead	 ; 
	ldi r18,lo8(1)	 ;  _4,
	sbiw r24,0	 ;  _3,
	brne .L3		 ; ,
	ldi r18,0		 ;  _4
.L3:
 ;  static.cc:13:   static bool A = digitalRead(PIN_ENCODER_CHANNEL_A);
	sts _ZZ13channel_a_isrvE1A,r18	 ;  A, _4
	ldi r24,lo8(_ZGVZ13channel_a_isrvE1A)	 ;  _ZGVZ13channel_a_isrvE1A.1_5,
	ldi r25,hi8(_ZGVZ13channel_a_isrvE1A)	 ;  _ZGVZ13channel_a_isrvE1A.1_5,
	ldi r18,lo8(1)	 ;  tmp59,
	movw r30,r24	 ; , _ZGVZ13channel_a_isrvE1A.1_5
	st Z,r18		 ;  MEM[(char *)_ZGVZ13channel_a_isrvE1A.1_5], tmp59
.L2:
 ;  static.cc:14:   static bool B = digitalRead(PIN_ENCODER_CHANNEL_B);
	ldi r24,lo8(_ZGVZ13channel_a_isrvE1B)	 ;  _ZGVZ13channel_a_isrvE1B.2_6,
	ldi r25,hi8(_ZGVZ13channel_a_isrvE1B)	 ;  _ZGVZ13channel_a_isrvE1B.2_6,
	movw r30,r24	 ; , _ZGVZ13channel_a_isrvE1B.2_6
	ld r24,Z		 ;  _7, MEM[(char *)_ZGVZ13channel_a_isrvE1B.2_6]
	cp r24, __zero_reg__	 ;  _7
	brne .L4		 ; ,
 ;  static.cc:14:   static bool B = digitalRead(PIN_ENCODER_CHANNEL_B);
	ldi r24,lo8(3)	 ; ,
	call digitalRead	 ; 
	ldi r18,lo8(1)	 ;  _9,
	sbiw r24,0	 ;  _8,
	brne .L5		 ; ,
	ldi r18,0		 ;  _9
.L5:
 ;  static.cc:14:   static bool B = digitalRead(PIN_ENCODER_CHANNEL_B);
	sts _ZZ13channel_a_isrvE1B,r18	 ;  B, _9
	ldi r24,lo8(_ZGVZ13channel_a_isrvE1B)	 ;  _ZGVZ13channel_a_isrvE1B.3_10,
	ldi r25,hi8(_ZGVZ13channel_a_isrvE1B)	 ;  _ZGVZ13channel_a_isrvE1B.3_10,
	ldi r18,lo8(1)	 ;  tmp61,
	movw r30,r24	 ; , _ZGVZ13channel_a_isrvE1B.3_10
	st Z,r18		 ;  MEM[(char *)_ZGVZ13channel_a_isrvE1B.3_10], tmp61
.L4:
 ;  static.cc:16:   steps += A ^ B ? 1 : -1;
	lds r25,_ZZ13channel_a_isrvE1A	 ;  A.5_11, A
	lds r24,_ZZ13channel_a_isrvE1B	 ;  B.6_12, B
 ;  static.cc:16:   steps += A ^ B ? 1 : -1;
	cp r25,r24		 ;  A.5_11, B.6_12
	breq .L6		 ; ,
 ;  static.cc:16:   steps += A ^ B ? 1 : -1;
	ldi r24,lo8(1)	 ;  iftmp.4_15,
	ldi r25,0		 ;  iftmp.4_15
	ldi r26,0		 ;  iftmp.4_15
	ldi r27,0		 ;  iftmp.4_15
	rjmp .L7		 ; 
.L6:
 ;  static.cc:16:   steps += A ^ B ? 1 : -1;
	ldi r24,lo8(-1)	 ;  iftmp.4_15,
	ldi r25,lo8(-1)	 ;  iftmp.4_15,
	movw r26,r24	 ;  iftmp.4_15
.L7:
 ;  static.cc:16:   steps += A ^ B ? 1 : -1;
	lds r20,_ZL5steps	 ;  steps.7_13, steps
	lds r21,_ZL5steps+1	 ;  steps.7_13, steps
	lds r22,_ZL5steps+2	 ;  steps.7_13, steps
	lds r23,_ZL5steps+3	 ;  steps.7_13, steps
	add r24,r20	 ;  _14, steps.7_13
	adc r25,r21	 ;  _14, steps.7_13
	adc r26,r22	 ;  _14, steps.7_13
	adc r27,r23	 ;  _14, steps.7_13
	sts _ZL5steps,r24	 ;  steps, _14
	sts _ZL5steps+1,r25	 ;  steps, _14
	sts _ZL5steps+2,r26	 ;  steps, _14
	sts _ZL5steps+3,r27	 ;  steps, _14
</code></pre>
<h4 id="ints"><a class="header" href="#ints"><a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/int.s"><code>int.s</code></a></a></h4>
<pre><code> ;  int.cc:13:   int A = digitalRead(PIN_ENCODER_CHANNEL_A);
	ldi r24,lo8(2)	 ; ,
	call digitalRead	 ; 
	std Y+2,r25	 ;  A,
	std Y+1,r24	 ;  A,
 ;  int.cc:14:   int B = digitalRead(PIN_ENCODER_CHANNEL_B);
	ldi r24,lo8(3)	 ; ,
	call digitalRead	 ; 
	std Y+4,r25	 ;  B,
	std Y+3,r24	 ;  B,
 ;  int.cc:16:   steps += A ^ B ? 1 : -1;
	ldd r18,Y+1	 ;  tmp46, A
	ldd r19,Y+2	 ;  tmp46, A
	ldd r24,Y+3	 ;  tmp47, B
	ldd r25,Y+4	 ;  tmp47, B
	cp r18,r24	 ;  tmp46, tmp47
	cpc r19,r25	 ;  tmp46, tmp47
	breq .L2		 ; ,
 ;  int.cc:16:   steps += A ^ B ? 1 : -1;
	ldi r24,lo8(1)	 ;  iftmp.0_3,
	ldi r25,0		 ;  iftmp.0_3
	ldi r26,0		 ;  iftmp.0_3
	ldi r27,0		 ;  iftmp.0_3
	rjmp .L3		 ; 
.L2:
 ;  int.cc:16:   steps += A ^ B ? 1 : -1;
	ldi r24,lo8(-1)	 ;  iftmp.0_3,
	ldi r25,lo8(-1)	 ;  iftmp.0_3,
	movw r26,r24	 ;  iftmp.0_3
.L3:
 ;  int.cc:16:   steps += A ^ B ? 1 : -1;
	lds r20,_ZL5steps	 ;  steps.1_1, steps
	lds r21,_ZL5steps+1	 ;  steps.1_1, steps
	lds r22,_ZL5steps+2	 ;  steps.1_1, steps
	lds r23,_ZL5steps+3	 ;  steps.1_1, steps
	add r24,r20	 ;  _2, steps.1_1
	adc r25,r21	 ;  _2, steps.1_1
	adc r26,r22	 ;  _2, steps.1_1
	adc r27,r23	 ;  _2, steps.1_1
	sts _ZL5steps,r24	 ;  steps, _2
	sts _ZL5steps+1,r25	 ;  steps, _2
	sts _ZL5steps+2,r26	 ;  steps, _2
	sts _ZL5steps+3,r27	 ;  steps, _2
</code></pre>
<p>This output can be hard to interpret if you’ve never read or written assembly before, but I’d like to draw your attention to one thing: the difference in function body length for the <code>static</code> case.
Again, for the seasoned C++ programmer, this hint might be a dead giveaway; however, let us probe a bit further.</p>
<p>Let’s take a closer look at the following block in <a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/static.s"><code>static.s</code></a>:</p>
<pre><code> ;  static.cc:13:   static bool A = digitalRead(PIN_ENCODER_CHANNEL_A);
	ldi r24,lo8(_ZGVZ13channel_a_isrvE1A)	 ;  _ZGVZ13channel_a_isrvE1A.0_1,
	ldi r25,hi8(_ZGVZ13channel_a_isrvE1A)	 ;  _ZGVZ13channel_a_isrvE1A.0_1,
	movw r30,r24	 ; , _ZGVZ13channel_a_isrvE1A.0_1
	ld r24,Z		 ;  _2, MEM[(char *)_ZGVZ13channel_a_isrvE1A.0_1]
	cp r24, __zero_reg__	 ;  _2
	brne .L2		 ; ,
 ;  static.cc:13:   static bool A = digitalRead(PIN_ENCODER_CHANNEL_A);
	ldi r24,lo8(2)	 ; ,
	call digitalRead	 ; 
	ldi r18,lo8(1)	 ;  _4,
	sbiw r24,0	 ;  _3,
	brne .L3		 ; ,
	ldi r18,0		 ;  _4
.L3:
 ;  static.cc:13:   static bool A = digitalRead(PIN_ENCODER_CHANNEL_A);
	sts _ZZ13channel_a_isrvE1A,r18	 ;  A, _4
	ldi r24,lo8(_ZGVZ13channel_a_isrvE1A)	 ;  _ZGVZ13channel_a_isrvE1A.1_5,
	ldi r25,hi8(_ZGVZ13channel_a_isrvE1A)	 ;  _ZGVZ13channel_a_isrvE1A.1_5,
	ldi r18,lo8(1)	 ;  tmp59,
	movw r30,r24	 ; , _ZGVZ13channel_a_isrvE1A.1_5
	st Z,r18		 ;  MEM[(char *)_ZGVZ13channel_a_isrvE1A.1_5], tmp59
.L2:
 ;  static.cc:14:   static bool B = digitalRead(PIN_ENCODER_CHANNEL_B);
	ldi r24,lo8(_ZGVZ13channel_a_isrvE1B)	 ;  _ZGVZ13channel_a_isrvE1B.2_6,
</code></pre>
<p>In particular, <code>cp r24, __zero_reg__</code> followed by <code>brne .L2</code>.</p>
<p>This bit of assembly essentially skips over our call to <a href="https://docs.arduino.cc/language-reference/en/functions/digital-io/digitalwrite/"><code>digitalWrite()</code></a> when the byte stored at <code>_ZGVZ13channel_a_isrvE1A.0_1</code><sup class="footnote-reference" id="fr-name-mangling-1"><a href="#footnote-name-mangling">2</a></sup> is a non-zero value.
Unfortunately for us, this byte is always set to <code>1</code> following a call to <a href="https://docs.arduino.cc/language-reference/en/functions/digital-io/digitalwrite/"><code>digitalWrite()</code></a>.
The emission of these instructions stems from the <a href="https://timsong-cpp.github.io/cppwp/n4659/dcl.stc#4"><code>static</code> storage class specifier</a>, the <a href="https://timsong-cpp.github.io/cppwp/n4659/stmt.dcl#4">dynamic initialization of variables with the <code>static</code> storage class</a>, and their <a href="https://timsong-cpp.github.io/cppwp/n4659/basic.stc.static#def:static_storage_duration">storage duration</a>.</p>
<h2 id="so-what-does-this-mean"><a class="header" href="#so-what-does-this-mean">So What Does this Mean?</a></h2>
<p>Converting the C++17 draft to plain English: <strong>initialization of <code>static</code> variables in the function scope is done once</strong>.
In particular, the first time the function executes.
What this means for <a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/bug-hall-of-fame/static-initialization.d/static.cc"><code>static.cc</code></a> is that the values of <code>A</code> and <code>B</code> do not change following the first invocation of the <a href="https://docs.arduino.cc/language-reference/en/functions/external-interrupts/attachInterrupt/#parameters"><code>CHANGE</code> interrupt</a>.
As you can imagine, we can either get stuck counting in one direction, or we have the channel A and B ISRs fighting with one another, and <code>steps</code> oscillates!<sup class="footnote-reference" id="fr-oscillations-1"><a href="#footnote-oscillations">3</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-tunnel-vission">
<p>It’s crazy what kind of tunnel vision you can have while mortified at the thought of misguiding everyone with a hint! <a href="#fr-tunnel-vission-1">↩</a></p>
</li>
<li id="footnote-name-mangling">
<p>The reason why our <code>static</code> variable <code>A</code> has such a strange name is due to C++ name mangling. <a href="#fr-name-mangling-1">↩</a></p>
</li>
<li id="footnote-oscillations">
<p>For the few of you that experienced this bug, you may have noticed that the encoder count slowly changed given enough aggressive spinning of the encoder. Skipped interrupts are to blame! <a href="#fr-oscillations-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="how-tos"><a class="header" href="#how-tos">How-tos</a></h1>
<ul>
<li><a href="how-tos/debugwire.html">debugWire</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugwire"><a class="header" href="#debugwire">debugWire</a></h1>
<p>You’ll need two Arduino Uno Rev3s.
One will serve as our target, which will get debugged, while the other will act as the actual debugger.
To make this possible, we’ll be taking advantage of <a href="https://github.com/felias-fogg/dw-link"><code>dw-link</code></a> to turn one of the Arduinos into a debugger.</p>
<ol>
<li>Grab the <a href="https://github.com/felias-fogg/dw-link/releases">latest release</a> of <a href="https://github.com/felias-fogg/dw-link"><code>dw-link</code></a>.
<ol>
<li><strong>(Optionally)</strong> Feel free to read the <a href="https://github.com/felias-fogg/dw-link/blob/master/docs/manual.md"><code>dw-link</code> manual</a>.</li>
</ol>
</li>
<li>Compile and upload the sketch to your designated Arduino debugger.</li>
<li><a href="https://github.com/MCUdude/MiniCore#how-to-install">Install</a> <a href="https://github.com/MCUdude/MiniCore">MiniCore</a> using the board manager.</li>
<li>Set your board to be the MiniCore ATmega328, disable compiler LTO, and optimize sketches for debugging.</li>
<li>We have already enabled debugWire on all of the target boards, so it is sufficient to connect pin 8 of the debugger board to the reset pin of the target, along with power and ground to their respective locations.</li>
<li>Verify your sketch at least once before starting debugging.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solutions"><a class="header" href="#solutions">Solutions</a></h1>
<ul>
<li><a href="solutions/encoder-steps.html">Encoder Steps</a></li>
<li><a href="solutions/mpu-6050-driver.html">MPU-6050-driver</a></li>
<li><a href="solutions/scrolling-quad-seven-segment-display.html">Scrolling Quad Seven-Segment Display</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoder-steps"><a class="header" href="#encoder-steps">Encoder Steps</a></h1>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * encoder steps
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

#include "encoder.h"

const static uint32_t BAUD = 115200;

void setup(void)
{
  encoder_setup();

  Serial.begin(BAUD);
}

void loop(void)
{
  Serial.println(encoder_steps());
}
</code></pre>
<h2 id="encodercc"><a class="header" href="#encodercc"><code>encoder.cc</code></a></h2>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * encoder.cc -- encoder steps
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

#include "encoder.h"

#include "pins.h"

#include &lt;Arduino.h&gt;
#include &lt;stdint.h&gt;

static volatile uint32_t steps;

static void channel_isr(bool reverse)
{
	const uint8_t A = digitalRead(PIN_ENCODER_CHANNEL_A);
	const uint8_t B = digitalRead(PIN_ENCODER_CHANNEL_B);

	steps += A ^ B ^ reverse ? 1 : -1;
}

static void channel_a_isr(void)
{
	channel_isr(false);
}

static void channel_b_isr(void)
{
	channel_isr(true);
}

void encoder_setup(void)
{
	pinMode(PIN_ENCODER_CHANNEL_A, INPUT);
	pinMode(PIN_ENCODER_CHANNEL_B, INPUT);

	steps = 0;

	attachInterrupt(
		digitalPinToInterrupt(PIN_ENCODER_CHANNEL_A),
		channel_a_isr,
		CHANGE);
	attachInterrupt(
		digitalPinToInterrupt(PIN_ENCODER_CHANNEL_B),
		channel_b_isr,
		CHANGE);
}

uint32_t encoder_steps(void)
{
	return steps;
}
</code></pre>
<h2 id="encoderh"><a class="header" href="#encoderh"><code>encoder.h</code></a></h2>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * encoder.h -- encoder steps
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

#ifndef ENCODER_STEPS_ENCODER_H
#define ENCODER_STEPS_ENCODER_H

#include &lt;stdint.h&gt;

void     encoder_setup(void);
uint32_t encoder_steps(void);

#endif  // ENCODER_STEPS_ENCODER_H
</code></pre>
<h2 id="pinsh"><a class="header" href="#pinsh"><code>pins.h</code></a></h2>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * pins.h -- pinout
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

#ifndef ENCODER_STEPS_PINS_H
#define ENCODER_STEPS_PINS_H

#include &lt;stdint.h&gt;

const static uint8_t PIN_ENCODER_CHANNEL_A = 2;
const static uint8_t PIN_ENCODER_CHANNEL_B = 3;

#endif  // ENCODER_STEPS_PINS_H
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mpu-6050-driver"><a class="header" href="#mpu-6050-driver">MPU-6050 Driver</a></h1>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * main.c -- sample code to interface with MPU-6050 over TWI
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

#include "twi.h"

const uint32_t SCL_FREQUENCY = 100000;

int main(void)
{
	sei();

	uint8_t pin_mask = (1 &lt;&lt; PC5) | (1 &lt;&lt; PC4);

	DDRC  &amp;= ~pin_mask;
	PORTC |=  pin_mask;

	twi_status_t status = twi_init(SCL_FREQUENCY);

	if (status != TWI_STATUS_SUCCESS)
		return EXIT_FAILURE;

	return EXIT_SUCCESS;
}
</code></pre>
<h2 id="twih"><a class="header" href="#twih"><a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/solutions/mpu-6050-driver.d/twi.h"><code>twi.h</code></a></a></h2>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * twi.h -- two-wire serial interface master
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

#ifndef TWI_H
#define TWI_H

#include &lt;stddef.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;util/twi.h&gt;

typedef enum twi_status {
	TWI_STATUS_SUCCESS,
	TWI_STATUS_ARBITRATION_LOST,
	TWI_STATUS_BUSY,
	TWI_STATUS_BUS_ERROR,
	TWI_STATUS_CANCELLED,
	TWI_STATUS_DISABLED,
	TWI_STATUS_DOUBLE_INIT,
	TWI_STATUS_FAILURE,
	TWI_STATUS_INVALID_ADDRESS,
	TWI_STATUS_INVALID_SCL,
	TWI_STATUS_NACK,
	TWI_STATUS_NO_INFO,
	TWI_STATUS_WRITE_COLLISION,
} twi_status_t;

typedef struct twi_message {
	uint8_t  address;
	uint8_t *buffer;
	size_t   size;
} twi_message_t;

static const uint8_t TWI_READ = TW_READ;
static const uint8_t TWI_WRITE = TW_WRITE;

twi_status_t twi_cancel(void);
twi_status_t twi_deinit(void);
twi_status_t twi_enqueue(twi_message_t * const messages, size_t message_count);
twi_status_t twi_init(const uint32_t scl_frequency);
twi_status_t twi_status(void);

#endif  // TWI_H
</code></pre>
<h2 id="privatetwih"><a class="header" href="#privatetwih"><a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/solutions/mpu-6050-driver.d/private/twi.h"><code>private/twi.h</code></a></a></h2>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * twi.h -- two-wire serial interface master
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

#ifndef PRIVATE_TWI_H
#define PRIVATE_TWI_H

#include "../twi.h"

#include &lt;stdbool.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;

static const size_t TWI_MR_FINAL_BYTE = 1;

typedef struct twi_isr {
	bool           idle;
	twi_status_t   status;
	twi_message_t *messages;
	size_t         message_count;
} twi_isr_t;

static void clear_twsto(void);
static void return_isr(const twi_status_t status);
static bool scl_to_bitrate(
	const uint32_t f_scl,
	uint8_t * const twbr,
	uint8_t * const twps);

#endif  // PRIVATE_TWI_H
</code></pre>
<h2 id="twic"><a class="header" href="#twic"><a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/solutions/mpu-6050-driver.d/twi.c"><code>twi.c</code></a></a></h2>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * twi.c -- two-wire serial interface master
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

#include "twi.h"
#include "private/twi.h"

#include &lt;avr/interrupt.h&gt;
#include &lt;avr/io.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;util/twi.h&gt;

static volatile twi_isr_t twi_isr;

twi_status_t twi_cancel(void)
{
	const uint8_t sreg = SREG;

	cli();

	twi_isr = (twi_isr_t) {
		.idle   = true,
		.status = TWI_STATUS_CANCELLED,
	};

	uint8_t twcr = TWCR;

	twcr &amp;= 1 &lt;&lt; TWSTA;
	twcr |= 1 &lt;&lt; TWSTO;

	TWCR = twcr;

	clear_twsto();

	SREG = sreg;

	return TWI_STATUS_SUCCESS;
}

twi_status_t twi_deinit(void)
{
	if (twi_status() == TWI_STATUS_BUSY)
		return TWI_STATUS_BUSY;

	TWCR = 1 &lt;&lt; TWINT;

	return TWI_STATUS_SUCCESS;
}

twi_status_t twi_enqueue(twi_message_t * const messages, size_t message_count)
{
	const uint8_t sreg = SREG;

	cli();

	const uint8_t twcr = TWCR;
	const bool    idle = twi_isr.idle;

	SREG = sreg;

	if (!(twcr &amp; (1 &lt;&lt; TWEN)))
		return TWI_STATUS_DISABLED;

	if (!idle)
		return TWI_STATUS_BUSY;

	twi_isr = (twi_isr_t) {
		.idle          = false,
		.messages      = messages,
		.message_count = message_count,
	};


	TWCR = twcr | (1 &lt;&lt; TWSTA);

	return TWI_STATUS_SUCCESS;
}

twi_status_t twi_init(const uint32_t scl_frequency)
{
	const uint8_t sreg = SREG;

	cli();

	const bool double_init = TWCR &amp; (1 &lt;&lt; TWEN);

	SREG = sreg;

	if (double_init)
		return TWI_STATUS_DOUBLE_INIT;

	uint8_t twbr;
	uint8_t twps;

	if (!scl_to_bitrate(scl_frequency, &amp;twbr, &amp;twps))
		return TWI_STATUS_INVALID_SCL;

	TWBR = twbr;
	TWSR = twps;

	TWAR = ~(1 &lt;&lt; TWGCE);
	TWAMR = 0xFF;

	TWCR
		= (1 &lt;&lt; TWINT)
		| (0 &lt;&lt; TWEA)
		| (0 &lt;&lt; TWSTA)
		| (0 &lt;&lt; TWSTO)
		| (1 &lt;&lt; TWEN)
		| (1 &lt;&lt; TWIE);

	twi_isr = (twi_isr_t) {
		.idle = true,
		.status = TWI_STATUS_SUCCESS,
	};

	return TWI_STATUS_SUCCESS;
}

twi_status_t twi_status(void)
{
	const uint8_t sreg = SREG;

	cli();

	const twi_status_t status
		= twi_isr.idle
		? twi_isr.status
		: TWI_STATUS_BUSY;

	SREG = sreg;

	return status;
}

static void clear_twsto(void)
{
	// If a user enqueues a new set of messages while the STOP
	// condition is asserted on the bus, triggering a START
	// condition will result in a bus error. To avoid this, we wait
	// for TWSTO to be automatically get cleared by hardware. This
	// does however introduce an unavoidable delay of ~15 us in our
	// code (when running at 16 MHz) which is irritating, however,
	// it's a tradeoff worth making if it means users of our driver
	// don't need to deal with spurious bus errors.
	while (TWCR &amp; (1 &lt;&lt; TWSTO))
		continue;
}

static void return_isr(const twi_status_t status)
{
	twi_isr = (twi_isr_t) {
		.idle   = true,
		.status = status,
	};
}

static bool scl_to_bitrate(
	const uint32_t f_scl,
	uint8_t * const twbr,
	uint8_t * const twps)
{
	// To avoid float-based division we perform a fixed-point
	// division by left shifting by 32. For this assumption to hold,
	// we must ensure that F_CPU stays below 1ULL &lt;&lt; 32.
	static_assert(
		F_CPU &lt; (1ULL &lt;&lt; 32),
		"F_CPU must be less than 1ULL &lt;&lt; 32");
	const uint64_t f_cpu = F_CPU &lt;&lt; 32;

	// We have that F_SCL = F_CPU / (16 + (2 * TWBR * prescale)).
	// To solve for TWBR and the prescale value iteratively, we
	// rearrange this equality to the expression below.
	const uint64_t target = ((f_cpu / f_scl) - (16ULL &lt;&lt; 32)) / 2;

	const bool f_cpu_sufficient = target &gt;&gt; 32;
	if (!f_cpu_sufficient) return false;

	for (*twps = 0; *twps &lt; 4; (*twps)++) {
		const uint8_t prescaler = 1 &lt;&lt; (*twps * 2);

		const uint64_t result = target / prescaler;
		const uint32_t potential_twbr
			= (result &gt;&gt; 32) + ((bool) (result &amp; (1ULL &lt;&lt; 31)));

		// We've exhausted our prescaler.
		if (!potential_twbr)
			break;

		if (potential_twbr &lt;= UINT8_MAX) {
			*twbr = potential_twbr;
			return true;
		}
	}

	return false;
}

ISR(TWI_vect)
{
	static unsigned char *buffer;
	static size_t         size;

	twi_status_t status = TWI_STATUS_FAILURE;

	if (TWCR &amp; (1 &lt;&lt; TWWC)) {
		status = TWI_STATUS_WRITE_COLLISION;
		goto error;
	}

	twi_message_t * const message = twi_isr.messages;

	switch (TW_STATUS) {
		case TW_START:
		case TW_REP_START:
			TWDR = message-&gt;address;

			buffer = message-&gt;buffer;
			size   = message-&gt;size;

			uint8_t twcr = TWCR &amp; ~(1 &lt;&lt; TWSTA);

			const bool mr_mode = message-&gt;address &amp; 1;

			if (mr_mode)
				twcr |= 1 &lt;&lt; TWEA;

			TWCR = twcr;

			return;

		case TW_MT_SLA_ACK:
		case TW_MT_DATA_ACK:
			if (!size--) {
				const uint8_t bit
					= --twi_isr.message_count
					? ++twi_isr.messages, TWSTA
					: TWSTO;

				if (bit == TWSTO)
					return_isr(TWI_STATUS_SUCCESS);

				TWCR |= 1 &lt;&lt; bit;

				if (bit == TWSTO)
					clear_twsto();

				return;
			}

			TWDR  = *(buffer++);
			TWCR |= 1 &lt;&lt; TWINT;

			return;

		case TW_MR_DATA_NACK:
			if (size-- != TWI_MR_FINAL_BYTE) {
				status = TWI_STATUS_NACK;

				break;
			}

			[[fallthrough]];

		case TW_MR_DATA_ACK:
			if (!size--) {
				const uint8_t bit
					= --twi_isr.message_count
					? ++twi_isr.messages, TWSTA
					: TWSTO;

				if (bit == TWSTO)
					return_isr(TWI_STATUS_SUCCESS);

				TWCR |= 1 &lt;&lt; bit;

				if (bit == TWSTO)
					clear_twsto();

				return;
			}

			*(buffer++) = TWDR;

			[[fallthrough]];

		case TW_MR_SLA_ACK:
			TWCR
				= size == TWI_MR_FINAL_BYTE
				? TWCR &amp; ~(1 &lt;&lt; TWEA)
				: TWCR;

			return;

		case TW_MR_SLA_NACK:
		case TW_MT_DATA_NACK:
		case TW_MT_SLA_NACK:
			status = TWI_STATUS_NACK;
			break;

		//   TW_MT_ARB_LOST:
		case TW_MR_ARB_LOST:
			status = TWI_STATUS_ARBITRATION_LOST;
			break;

		case TW_NO_INFO:
			status = TWI_STATUS_NO_INFO;
			break;

		case TW_BUS_ERROR:
			status = TWI_STATUS_BUS_ERROR;
			break;

		default:
			break;
	}

error:
	return_isr(status);

	TWCR |= 1 &lt;&lt; TWSTO;

	clear_twsto();
}
</code></pre>
<h2 id="makefile-1"><a class="header" href="#makefile-1"><a href="https://github.com/jacobkoziej/cu-summer-stem-embedded-systems/blob/master/src/solutions/mpu-6050-driver.d/Makefile"><code>Makefile</code></a></a></h2>
<pre><code class="language-cpp">CC      = avr-gcc
CFLAGS += \
	-DF_CPU=16000000ULL \
	-O0 \
	-Wall \
	-Wextra \
	-Wpedantic \
	-g \
	-mmcu=atmega328p \
	-std=c23 \

.PHONY: all
all: main.elf

.PHONY: clean
clean:
	@rm -rvf *.d *.elf *.o

main.elf: main.o twi.o
	$(CC) $(CFLAGS) -o $@ $^

%.o: %.c
	$(CC) $(CFLAGS) -MM -MF $*.d $&lt;
	$(CC) $(CFLAGS) -c $&lt;

-include $(wildcard *.d)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrolling-quad-seven-segment-display"><a class="header" href="#scrolling-quad-seven-segment-display">Scrolling Quad Seven-Segment Display</a></h1>
<pre><code class="language-cpp">// SPDX-License-Identifier: MPL-2.0
/*
 * scrolling quad seven-segment display
 * Copyright (C) 2025  Jacob Koziej &lt;jacobkoziej@gmail.com&gt;
 */

/*
 * Here we create a constant array of characters for the message we wish
 * to scroll on the seven segment display along with the scrolling delay
 * and time each digit is enabled in microseconds.
 *
 * NOTE: when calculating the message size, we subtract one from the
 * result of sizeof(). This is because the string literal we used for
 * assignment includes a trailing NULL character. Since this is not a
 * printable, we simply exclude it.
 */
static const char     MESSAGE[]       = "COOPER EE25 ";
static const uint8_t  MESSAGE_SIZE    = sizeof(MESSAGE) - 1;
static const int32_t  SCROLL_DELAY_US = 500000;
static const uint16_t DIGIT_TIME_US   = 250;

/*
 * Here we map each segment to an array and bit index for a seven-
 * segment digit. In this case, we treat the LSB as a decimal point and
 * the MSB as segment A.
 */
enum {
  SEGMENT_DP,
  SEGMENT_G,
  SEGMENT_F,
  SEGMENT_E,
  SEGMENT_D,
  SEGMENT_C,
  SEGMENT_B,
  SEGMENT_A,
  SEGMENTS_TOTAL,
};

/*
 * Here we create a lookup table that maps segment index to pin number
 * on the Arduino Uno Rev3. We explicitly assign with the array index as
 * to make this code "self documenting" and reduce the probability of
 * incorrect assignments while editing the order of pins.
 */
static const uint8_t SEGMENT_TO_PIN[SEGMENTS_TOTAL] = {
  [SEGMENT_DP] = 8,
  [SEGMENT_G]  = 7,
  [SEGMENT_F]  = 4,
  [SEGMENT_E]  = 2,
  [SEGMENT_D]  = A3,
  [SEGMENT_C]  = A2,
  [SEGMENT_B]  = A1,
  [SEGMENT_A]  = A0,
};

/*
 * Since a display can possibly have any number of digits, we don't go
 * through the effort of creating an enum for each of the digits (unless
 * there's a need to refer to specific digits by name). We also store
 * the number of digits using sizeof() so that the constant dynamically
 * updates if we were to add/remove digits in the future.
 *
 * NOTE: we divide the size of the array by the size of the first
 * element as there is no guarantee that a uint8_t is the smallest
 * integer size on our target architecture unlike a char.
 */
static const uint8_t DIGIT_TO_PIN[] = {9, 6, 5, 3};
static const uint8_t DIGITS_TOTAL
  = sizeof(DIGIT_TO_PIN) / sizeof(DIGIT_TO_PIN[0]);

/*
 * In our case, the quad seven-segment display digits are active low
 * while segments are active high. If we were to change our display in
 * the future, we can just change the following constants to adjust the
 * logic levels elsewhere in our code as opposed to inverting a bunch of
 * HIGH/LOW constants.
 */
static const uint8_t DIGIT_ON    = LOW;
static const uint8_t DIGIT_OFF   = HIGH;
static const uint8_t SEGMENT_ON  = HIGH;
static const uint8_t SEGMENT_OFF = LOW;

/*
 * Since we're only concerned with a subset of the printable ASCII
 * characters, we create a condensed lookup table with bitmasks we can
 * show on the seven-segment display. To facilitate this reduced lookup
 * table size, we must also write a function that remaps ASCII values.
 */
static const uint8_t ASCII_DIGIT_OFFSET  = 1;
static const uint8_t ASCII_LETTER_OFFSET = 10 + ASCII_DIGIT_OFFSET;

static const uint8_t ASCII_LOOKUP[] = {
  [' ' - ' ']                       = 0b00000000,
  ['0' - '0' + ASCII_DIGIT_OFFSET]  = 0b11111100,
  ['1' - '0' + ASCII_DIGIT_OFFSET]  = 0b01100000,
  ['2' - '0' + ASCII_DIGIT_OFFSET]  = 0b11011010,
  ['3' - '0' + ASCII_DIGIT_OFFSET]  = 0b11110010,
  ['4' - '0' + ASCII_DIGIT_OFFSET]  = 0b01100110,
  ['5' - '0' + ASCII_DIGIT_OFFSET]  = 0b10110110,
  ['6' - '0' + ASCII_DIGIT_OFFSET]  = 0b00111110,
  ['7' - '0' + ASCII_DIGIT_OFFSET]  = 0b11100000,
  ['8' - '0' + ASCII_DIGIT_OFFSET]  = 0b11111110,
  ['9' - '0' + ASCII_DIGIT_OFFSET]  = 0b11110110,
  ['a' - 'a' + ASCII_LETTER_OFFSET] = 0b11101110,
  ['b' - 'a' + ASCII_LETTER_OFFSET] = 0b00111110,
  ['c' - 'a' + ASCII_LETTER_OFFSET] = 0b10011100,
  ['d' - 'a' + ASCII_LETTER_OFFSET] = 0b01111010,
  ['e' - 'a' + ASCII_LETTER_OFFSET] = 0b10011110,
  ['f' - 'a' + ASCII_LETTER_OFFSET] = 0b10001110,
  ['g' - 'a' + ASCII_LETTER_OFFSET] = 0b11110110,
  ['h' - 'a' + ASCII_LETTER_OFFSET] = 0b00101110,
  ['i' - 'a' + ASCII_LETTER_OFFSET] = 0b00100000,
  ['j' - 'a' + ASCII_LETTER_OFFSET] = 0b01111000,
  ['k' - 'a' + ASCII_LETTER_OFFSET] = 0b01101110,
  ['l' - 'a' + ASCII_LETTER_OFFSET] = 0b00011100,
  ['m' - 'a' + ASCII_LETTER_OFFSET] = 0b10101010,
  ['n' - 'a' + ASCII_LETTER_OFFSET] = 0b00101010,
  ['o' - 'a' + ASCII_LETTER_OFFSET] = 0b00111010,
  ['p' - 'a' + ASCII_LETTER_OFFSET] = 0b11001110,
  ['q' - 'a' + ASCII_LETTER_OFFSET] = 0b11100110,
  ['r' - 'a' + ASCII_LETTER_OFFSET] = 0b00001010,
  ['s' - 'a' + ASCII_LETTER_OFFSET] = 0b10110110,
  ['t' - 'a' + ASCII_LETTER_OFFSET] = 0b00011110,
  ['u' - 'a' + ASCII_LETTER_OFFSET] = 0b00111000,
  ['v' - 'a' + ASCII_LETTER_OFFSET] = 0b01111100,
  ['w' - 'a' + ASCII_LETTER_OFFSET] = 0b10111000,
  ['x' - 'a' + ASCII_LETTER_OFFSET] = 0b01101110,
  ['y' - 'a' + ASCII_LETTER_OFFSET] = 0b01110110,
  ['z' - 'a' + ASCII_LETTER_OFFSET] = 0b11011010,
};

/*
 * Here we create a function that maps ASCII characters to our lookup
 * table indices. This function checks ranges of contiguous ASCII
 * characters and adds appropriate offsets.
 */
static uint8_t ascii_to_index(const char c)
{
  if (c == ' ')
    return c - ' ';

  if ((c &gt;= '0') &amp;&amp; (c &lt;= '9'))
    return c - '0' + ASCII_DIGIT_OFFSET;

  if ((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z'))
    return c - 'A' + ASCII_LETTER_OFFSET;

  if ((c &gt;= 'a') &amp;&amp; (c &lt;= 'z'))
    return c - 'a' + ASCII_LETTER_OFFSET;

  return 0;
}

/*
 * To simplify using the seven-segment display, we create a function,
 * that given a bitmask, will write it to the display using the bit
 * values as to identify which segments to turn on/off.
 */
static void digit_write(const uint8_t digit)
{
  for (size_t i = 0; i &lt; SEGMENTS_TOTAL; i++)
    digitalWrite(
      SEGMENT_TO_PIN[i],
      digit &amp; (1 &lt;&lt; i) ? SEGMENT_ON : SEGMENT_OFF);
}

void setup(void)
{
  // on reset, we disable the display to get it into a consistent state

  for (size_t i = 0; i &lt; DIGITS_TOTAL; i++) {
    digitalWrite(DIGIT_TO_PIN[i], DIGIT_OFF);
    pinMode(DIGIT_TO_PIN[i], OUTPUT);
  };

  for (size_t i = 0; i &lt; SEGMENTS_TOTAL; i++) {
    digitalWrite(SEGMENT_TO_PIN[i], SEGMENT_OFF);
    pinMode(SEGMENT_TO_PIN[i], OUTPUT);
  };
}

void loop(void)
{
  static uint8_t index;
  static int32_t scroll_delay_us = SCROLL_DELAY_US;

  for (size_t i = 0; i &lt; DIGITS_TOTAL; i++) {
    const uint8_t letter = MESSAGE[(index + i) % MESSAGE_SIZE];
    const uint8_t digit  = ASCII_LOOKUP[ascii_to_index(letter)];

    // set segments before enabling digits to reduce flicker
    digit_write(digit);

    digitalWrite(DIGIT_TO_PIN[i], DIGIT_ON);
    delayMicroseconds(DIGIT_TIME_US);
    digitalWrite(DIGIT_TO_PIN[i], DIGIT_OFF);
  }

  scroll_delay_us -= DIGITS_TOTAL * DIGIT_TIME_US;

  if (scroll_delay_us &lt;= 0) {
    index = (index + 1) % MESSAGE_SIZE;

    scroll_delay_us = SCROLL_DELAY_US;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h1>
<ul>
<li><a href="https://docs.arduino.cc/language-reference/">Arduino Language Reference</a></li>
<li><a href="https://docs.arduino.cc/hardware/uno-rev3/">Arduino Uno Rev3 Hardware Information</a></li>
<li><a href="https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf">ATmega328P Datasheet</a></li>
<li><a href="https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/ATmega48A-PA-88A-PA-168A-PA-328-P-DS-DS40002061B.pdf">ATmega48A/PA/88A/PA/168A/PA/328/P Datasheet</a></li>
<li><a href="https://www.professordan.com/avr/techlib/techlib8/appnotes/">AVR Application Notes</a></li>
<li><a href="https://gcc.gnu.org/wiki/avr-gcc#ABI">AVR GCC Application Binary Interface</a></li>
<li><a href="https://avrdudes.github.io/avr-libc/">AVR-LibC Documentation</a></li>
<li><a href="https://avrdudes.github.io/avrdude/">AVRDUDE Documentation</a></li>
<li><a href="https://cdecl.org/">cdecl</a></li>
<li><a href="https://explainshell.com/">Explain Shell</a></li>
<li><a href="https://github.com/osx-cross/homebrew-avr">Homebrew AVR Toolchain</a></li>
<li><a href="https://brew.sh/">Homebrew</a></li>
<li><a href="https://makefiletutorial.com/">Makefile Tutorial By Example</a></li>
<li><a href="https://www.mankier.com/">ManKier</a></li>
<li><a href="https://tldr.sh/">TLDR Pages</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL Installation</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-9aeb6ddf.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-9576a2db.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
